{
  "competitive programming boilerplate": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main() {",
      "  ios::sync_with_stdio(0);",
      "  cin.tie(0);",
      "  $0",
      "  return 0;",
      "}"
    ]
  },
  "fast power": {
    "prefix": ["fp", "power"],
    "body": [
      "int fp(int a, int b) {",
      "  int ans = 1;",
      "  while (b > 0) {",
      "    if (b & 1)",
      "      ans = (ans * a) % MOD",
      "    a = a * a % MOD",
      "    b >>= 1;",
      "  }",
      "  return ans;",
      "}"
    ]
  },
  "fenwick tree": {
    "prefix": ["fenwick", "bit"],
    "body": [
      "vector<${2:long long}> bit_vec;",
      "",
      "int lowbit(int n) { return n & (-n); }",
      "",
      "void bit_init(const vector<{1:int}> &vec) {",
      "  int size = vec.size() + 1;",
      "  bit_vec.resize(size, 0);",
      "",
      "  for (int i = 0; i < size; i++) {",
      "    bit_vec[i + 1] = vec[i];",
      "  }",
      "",
      "  for (int pos = 1; pos < size; pos++) {",
      "    int next = pos + lowbit(pos);",
      "    if (next < size) {",
      "      bit_vec[next] += bit_vec[pos];",
      "    }",
      "  }",
      "}",
      "",
      "/** 1-indexed */",
      "void bit_add(int i, ${1:int} diff) {",
      "  for (int pos = i; pos < bit_vec.size(); pos += lowbit(pos)) {",
      "    bit_vec[pos] += diff;",
      "  }",
      "}",
      "",
      "/** 1-indexed */",
      "${2:long long} bit_prefix_sum(int i) {",
      "  ${2:long long} sum = 0;",
      "  for (int pos = i; pos >= 1; pos -= lowbit(pos)) {",
      "    sum += bit_vec[pos];",
      "  }",
      "  return sum;",
      "}",
      "",
      "/** 1-based */",
      "${2:long long} bit_range_sum(int i, int j) {",
      "  return bit_prefix_sum(j) - bit_prefix_sum(i - 1);",
      "}"
    ]
  },
  "segment tree": {
    "prefix": "seg",
    "body": [
      "/** initilize to 4n size */",
      "vector<${1:long long}> sum;",
      "vector<${1:long long}> lazy;",
      "",
      "/** 1-indexed args; vec is 0-indexed */",
      "void seg_build(const vector<int> &vec, int i, int node_l, int node_r) {",
      "  if (node_l == node_r) {",
      "    sum[i] = vec[node_l - 1];",
      "    return;",
      "  }",
      "",
      "  int mid = node_l + (node_r - node_l) / 2;",
      "",
      "  seg_build(vec, 2 * i, node_l, mid);",
      "  seg_build(vec, 2 * i + 1, mid + 1, node_r);",
      "",
      "  sum[i] = sum[2 * i] + sum[2 * i + 1];",
      "}",
      "",
      "/** 1-indexed */",
      "void seg_push_down(int i, int node_l, int node_r) {",
      "  if (node_l == node_r || lazy[i] == 0)",
      "    return;",
      "",
      "  int mid = node_l + (node_r - node_l) / 2, lefti = 2 * i, righti = 2 * i + 1;",
      "",
      "  sum[lefti] += lazy[i] * (mid - node_l + 1);",
      "  sum[righti] += lazy[i] * (node_r - mid);",
      "  lazy[lefti] += lazy[i];",
      "  lazy[righti] += lazy[i];",
      "",
      "  lazy[i] = 0;",
      "}",
      "",
      "/** 1-indexed */",
      "void seg_add(int l, int r, ${1:long long} x, int i, int node_l, int node_r) {",
      "  if (l > node_r || r < node_l)",
      "    return;",
      "  if (l <= node_l && node_r <= r) {",
      "    sum[i] += x * (node_r - node_l + 1);",
      "    lazy[i] += x;",
      "    return;",
      "  }",
      "",
      "  seg_push_down(i, node_l, node_r);",
      "",
      "  int mid = node_l + (node_r - node_l) / 2;",
      "  seg_add(l, r, x, 2 * i, node_l, mid);",
      "  seg_add(l, r, x, 2 * i + 1, mid + 1, node_r);",
      "",
      "  sum[i] = sum[2 * i] + sum[2 * i + 1];",
      "}",
      "",
      "/** 1-indexed */",
      "${1:long long} seg_query(int l, int r, int i, int node_l, int node_r) {",
      "  if (l > node_r || r < node_l)",
      "    return 0;",
      "  if (l <= node_l && node_r <= r)",
      "    return sum[i];",
      "",
      "  seg_push_down(i, node_l, node_r);",
      "",
      "  int mid = node_l + (node_r - node_l) / 2;",
      "  return seg_query(l, r, 2 * i, node_l, mid) +",
      "         seg_query(l, r, 2 * i + 1, mid + 1, node_r);",
      "}"
    ]
  }
}
